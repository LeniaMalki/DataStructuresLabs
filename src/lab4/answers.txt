

/******************************************************************************
 *  DAT038, TDA417  Datastrukturer och algoritmer, LP2 2019
 *  Lab 4: Path finder
 ******************************************************************************/

Name of lab group: 67
Group member A:    Viktor Fredholm
Group member B:    Johannes Mattsson


/******************************************************************************
 *  How many hours did you spend on the assignment?
 *****************************************************************************/

Group member A:    15
Group member B:    15


/******************************************************************************
 *  List the minimal cost, shortest path, and nr of visited nodes,
 *  for each of the following invocations.
 *****************************************************************************/

$ java RunPathFinder dijkstra AdjacencyGraph graphs/AdjacencyGraph/citygraph-EU.txt "Volos, Greece" "Oulu, Finland"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder astar AdjacencyGraph graphs/AdjacencyGraph/citygraph-EU.txt "Volos, Greece" "Oulu, Finland"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder dijkstra NPuzzle 3 "/HFG/BED/C_A/" "/ABC/DEF/GH_/"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder astar NPuzzle 3 "/HFG/BED/C_A/" "/ABC/DEF/GH_/"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder dijkstra NPuzzle 3 "/HGF/BED/C_A/" "/ABC/DEF/GH_/"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder astar NPuzzle 3 "/HGF/BED/C_A/" "/ABC/DEF/GH_/"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder dijkstra GridGraph graphs/GridGraph/AR0011SR.map "23:161" "130:211"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder astar GridGraph graphs/GridGraph/AR0011SR.map "23:161" "130:211"

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder dijkstra WordLadder graphs/WordLadder/words-saldo.txt syster broder

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]

$ java RunPathFinder astar WordLadder graphs/WordLadder/words-saldo.txt syster broder

visited nodes: [...]
minimal cost:  [...]
shortest path: [...]


/******************************************************************************
 *  For which of the three classes GridGraph, WordLadder and NPuzzle,
 *  did the heuristics .guessCost() have the most impact?
 * 
 *  Why do you think this is the case?
 *****************************************************************************/

[...]


/******************************************************************************
 *  Show pseudo-code of the following methods that you implemented
 *****************************************************************************/

// WordLadder.outgoingEdges(String word)

[...]


// WordLadder.guessCost(String v, String w)

[...]


// GridGraph.guessCost(String v, String w)

[...]



/******************************************************************************
 *  Show pseudo-code of method .searchDijkstra() in PathFinder
 *****************************************************************************/

Showing without the commonSeach extracton mentioned below.

// PathFinder.searchDijkstra(V start, V goal)
visitedNodes = 0
edgeTo = new empty hash map from nodes to edges
distTo = new empty hash map from nodes to double

queue = new priority queue, with nodes as elements,
            and a comparator that compares distTo values
bestPath = new empty list of bestPath
visited = new empty set of nodes

add start to pq
distTo[start] = 0.0

while queue is not empty:
    v = delete minimal element from queue
    visitedNode++

    if v not in visited:
        add v to visited
        if v is the goal:
            while goal is not start
                add goal to bestPath
                set goal to next edge from goal
            add start to bestPath
            reverse bestPath

            cost = dist to current v
            SUCCESS: return bestPath and cost
        for every outgoing edge e from v:
            w = e.to()
            newdist = distTo[v] + e.weight()
            if distTo[w] > newdist:
                distTo[w] = newdist
                edgeTo[w] = e
                add w to queue
return FAILURE


/******************************************************************************
 *  What are the main differences between your implementations 
 *  of .searchAstar() and .searchDijkstra()?
 *****************************************************************************/

The comparator. We extracted all the common code into its own method commonSearch().
The difference in the comparator is A* adding guesscost to distTo before comparing.


/******************************************************************************
 *  Are there any known bugs / limitations?
 *****************************************************************************/

Not that we know of. It runs on Java 11 and 13.


/******************************************************************************
 *  Did you collaborate with any other students on this lab?
 *  If so, please write in what way you collaborated and with whom.
 *  Also include any resources (including the web) that you may
 *  may have used in creating your design.
 *****************************************************************************/

We used the given pseudocode and the DijkstraSP. Also Wikipedia for A*.


/******************************************************************************
 *  Describe any serious problems you encountered.                    
 *****************************************************************************/

Starting with searchDijkstra was hard until we got the pseudocode.


/******************************************************************************
 *  List any other comments here. Feel free to provide any feedback   
 *  on how much you learned from doing the assignment, and whether    
 *  you enjoyed doing it.                                             
 *****************************************************************************/


It was nice to improve on the search algorithms. As our first naive implementation of WordLadder was really bad compared
to the one submitted. It was sometimes a too open ended assignment. Getting pseudocode for Dijkstra helped.
  
